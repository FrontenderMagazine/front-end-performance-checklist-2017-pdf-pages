<h1>Чеклист производительности Front-End для 2017 </h1>
<p>
    Кто из Вас уже использует прогрессивную загрузку (progressive booting)
    в своих проектах? А как на счет <strong>tree-shaking</strong> и <strong>code-splitting</strong> в React и
    Angular? Успели ли Вы настроить под себя сжатие Brotli или Zopfli, сшивания
    OCSP (OCSP stapling) и сжатие HPACK (HPACK compression)? Не стоит так же забывать
    о подсказках ресурсов (resource hints), клиентских подсказках (client hints)
    и сдерживании CSS— и это не говоря уже о IPv6, HTTP/2 и сервис воркерах?
</p>
<p>
    Давайте вспомним дни, когда производительность часто откладывалась на второй план. Вспоминали о ней аж в конце проекта, и в большинстве случаев это сводилось к минификации, конкатенации и оптимизации содержимого, и, возможно, парой дополнительных строк в конфигурационном файле сервера. Оглядываясь на те времена, понимаешь, что ситуация значительно поменялась с тех пор.
    Производительность касается не только технической стороны вопроса: она действительно важна, нужно учитывать, как может отразится на производительности то или иное решение в момент создания дизайна. Производительность нужно постоянно замерять, отслеживать, и улучшать, и вечно-растущая сложность веб-технологий все чаще бросает разработчику вызов, делая невозможным отслеживание метрик, так как метрики будут значительно отличаться в зависимости от устройства, браузера, сетевого протокола, типа сети и задержки в ней (CDN-ы, ISP, кэши, прокси, фаерволы, балансировщики нагрузки и сами сервера играют большую роль в конечной производительности).

</p>
<p>
    Если бы Вам пришлось сделать обзор на все возможные технологии
    о которых придется помнить в случае если поставлена задача улучшить
    производительность Вашего сайта — от самого начала процесса и до
    финального релиза вебсайта — на что бы Вы обратили свое внимание?
    Ниже приведен (надеюсь, беспристрастный и объективный)
    <strong>чеклист производительности front-end’а для 2017 </strong>— обзор
    всех тем с которыми вам возможно придется столкнуться для обеспечения
    максимально быстрого отклика и плавности работы Вашего вебсайта.
    (Вы так же можете просто <a href="http://provide.smashingmagazine.com/performance-checklist/performance-checklist-1.0.pdf?_ga=1.67706521.905683373.1482741288"><strong>загрузить чеклист в PDF (ENG) (0.129 MB)</strong></a> ,
    <a href="#"
       target="_blank"><strong>загрузить чеклист в PDF (RUS) (0.129 MB)</strong></a>
    или <a href="http://provide.smashingmagazine.com/performance-checklist/performance-checklist-1.0.pages?_ga=1.63331879.905683373.1482741288"><strong>скачать чеклист в формате Apple Pages (ENG) (0.236 MB)</strong></a>. Cчастливой оптимизации!)

</p>

<h1>
    Чеклист производительности Front-End’а в 2017
</h1>
<p>
    Текущие микро-оптимизации — это отличная вещь, чтобы удерживать Ваш продукт в строю, но гораздо важнее предопределить какие цели перед Вами стоят и не забывать о них — измеримые цели, которые будут влиять на любые решения, принимаемые на протяжении всего процесса. Существует множество разнообразных моделей, и приведенные ниже – могут варьироваться, но главное — расставить в своем проекте правильные приоритеты.
</p>
<h2>ГОТОВИМСЯ, СТАВИМ ЦЕЛИ </h2>
<h3>
    1. Будь на 20% быстрее ближайшего соперника.
</h3>
<p>
    По результатам психологического исследования, оказалось, что если вы хотите
    что пользователь ощущал что Ваш вебсайт быстрее других, нужно быть как-минимум
    на 20% быстрее.  Не столь важно время полной загрузки и отображения страницы,
    как метрики, например, время начала рендера страницы, <a href="https://developers.google.com/web/tools/lighthouse/audits/first-meaningful-paint" target="_blank">первой
    значительной отрисовки страницы </a> (к примеру, время необходимое
    что бы страница отобразила ее преймущественный контент) и <a href="https://developers.google.com/web/tools/lighthouse/audits/time-to-interactive" target="_blank">время интерактивности</a>
    (то есть, время необходимое странице или, в большинстве
    случаев, SPA что бы предоставить пользователю возможность взаимодействия с ней).
    Измерить время начала рендера (с помощью <a href="http://www.webpagetest.org/" target="_blank">WebPagetest</a>)
    и время отображения первой
    значимой картинки (с помощью <a href="https://github.com/GoogleChrome/lighthouse" target="_blank">Lighthouse</a>) на  Moto G, на устройстве Samsung
    среднего уровня производительности и на добротном среднестатистическом устройстве,
    например Nexus 4, желательно (<i>пометка переводчика – для прогрессивного мира</i>)
    в <a href="https://www.smashingmagazine.com/2016/11/worlds-best-open-device-labs/" target="_blank">открытой лаборатории девайсов</a> (open device lab) — на стандартных скоростях 3G,
    4G и при подключении к точке доступа Wi-Fi.

</p>
<p>
    <img src="img/lighthouse.png" alt="Lighthouse, ПО для ревизии производительности от Google" />
    <br>  <i><strong>Lighthouse</strong>, ПО для ревизии производительности от Google.</i>
</p>
<p>
    Обратите внимание на Вашу аналитику, что бы определить, на чем зацикливаются пользователи.
    Тогда Вы сможете сымитировать 90% пользовательского экспириенса синтетическим
    тестированием. Соберите информацию, составьте таблицу, ужмите ее на 20%
    и таким образом определитесь с Вашими целями
    (например, с <a href="http://bradfrost.com/blog/post/performance-budget-builder/" target="_blank">бюджетом производительности</a>).
    Теперь у Вас есть что-то измеримое, на что нужно ориентироваться в тестировании. Держа в голове мысль о бюджете производительности, и предпринимая попытки написания хоть малейшего скрипта для уменьшения времени интерактивности Вы можете быть уверены, что вы на верном пути.
</p>
<p>
    <img src="img/perf_budget.png" alt="Билдер бюджета производительности от Брэда Фроста." />
    <br>
    <i><a href="http://bradfrost.com/blog/post/performance-budget-builder/" target="_blank">Билдер</a> бюджета производительности от Брэда Фроста.</i>

</p>
<p>
  <strong>
      Поделитесь чеклистом с коллегами.
  </strong>
    Удостоверьтесь что каждый член Вашей команды ознакомлен с данным чеклистом что бы избежать возможного недопонимания в будущем процессе. Каждое принятое решение имеет влияние на производительность, и проект будет только в выигрыше, если не только фронтендеры, но и UX и графические дизайнеры решаться следовать этому плану. Обозначьте решения дизайнера в бюджете производительности и расставьте приоритеты о которых упоминалось выше.


</p>
<h3>
    2. Время отклика 100-миллисекунд, 60 кадров в секунду.
</h3>
<p>
    Модель производительности RAIL ставит перед Вами амбициозные цели: приложите все усилия и предоставьте пользователю отклик в течении 100 миллисекунд после первого входа. Для создания возможности отклика <100 миллисекунд страница должна уступать управление главному потоку не позже чем через каждые <50 миллисекунд. Для точек повышенной нагрузки, как анимация, лучшим решением будет не добавлять ничего больше там, где Вы еще можете, и лишь самый минимум там, где вы уже не можете.
    Более того, каждый кадр анимации должен сменятся менее чем за 16 миллисекунд, тем самым Вы достигнете заветных 60 fps (1 секунда ÷ 60 = 16.6 миллисекунд) — а еще лучше – уложиться в пределы 10 миллисекунд. Вашему браузеру ведь нужно время что бы отрисовать новый кадр на экране, так что постарайтесь что бы исполнение Вашего кода завершилось в течении 16.6 миллисекунд.
    <a href="http://info.meteor.com/blog/optimistic-ui-with-meteor-latency-compensation" TARGET="_blank">Будьте оптимистом </a>и используйте время простоя с умом. Очевидно, что эта цель относится в большей степени к производительности во время выполнения, а не во время загрузки.


</p>
<h3>
    3. Первая значимая картинка через 1.25 секунды, индекс скорости меньше 1000.
</h3>
<p>
    Несмотря на сложность достижения, Вашей абсолютной целью должно быть начало отрисовки страницы уже через 1 секунду и значение
    <a href="https://sites.google.com/a/webpagetest.org/docs/using-webpagetest/metrics/speed-index" target="_blank">индекса скорости</a> менее 1000 (на высокоскоростном подключении). Максимально-допустимая длительность отрисовки первого значимого изображения – 1250 миллисекунд. Для мобильных устройств
    <a href="https://www.soasta.com/blog/google-mobile-web-performance-study/" target="_blank"> неплохим</a> показателем будет начало отрисовки страницы меньше чем через 3 секунды для 3G подключения. Если Ваши показатели слегка перевалили за это значения – ничего страшного, но старайтесь понизить эти показатели как можно сильнее.
</p>
<h2>
    ОПРЕДЕЛИМСЯ С ОКРУЖЕНИЕМ
</h2>
<h3>
    4. Выберите для себя и сконфигурируйте инструменты сборки.
</h3>
<p>
    Не стоит слишком зацикливаться на том, что считается трендовым инструментом в данный момент. Придерживайтесь в выборе собственных интересов в разработке, не важно будет ли это Grunt, Gulp, Webpack, PostCSS или комбинация инструментов. До тех пор, пока Вам удается получать достичь результатов быстро, и Вы не ощущаете проблем в процессе использования инструментов сборки – у Вас должно быть все хорошо.
</p>
<h3>
    5. Прогрессивное улучшение.
</h3>
<p>
    Смело делайте ставку на <a href="https://www.aaron-gustafson.com/notebook/insert-clickbait-headline-about-progressive-enhancement-here/" target="_blank">прогрессивное улучшение</a> в качестве ведущего принцип архитектуры вашего front-end’а. Сначала спроектируйте и реализуйте базовые возможности, и только потом, дополняйте их сложными фичами для подходящий браузеров, создавая
    <a href="https://resilientwebdesign.com/" target="_blank">отказоустойчивый интерфейс</a>. В том случае если ваш вебсайт работает быстро на медленном устройстве, со слабым браузером и посредственным интернетом, вы точно можете быть уверены, что он будет отлично работать на устройстве побыстрее, с современным браузером и хорошим интернет соединением.
</p>

<h3>
    6. Angular, React, Ember и компания.
</h3>
<p>
    Присмотритесь к Фреймворку, который
    позволяет отрисовать картинку на стороне сервера.
    Не забудьте замерять время загрузки как в режиме отрисовки на сервере,
    так и на клиенте для мобильных устройств, прежде чем приступать
    к работе с Фреймворком. (так как эти изменения в будущем может быть
    невероятно сложно воплотить). Если Вы уже используете JavaScript фреймворк,
    убедитесь, что Ваш выбор является <a href="https://www.youtube.com/watch?v=6I_GwgoGm1w" target="_blank">оптимальным</a> и
    <a href="https://medium.com/@ZombieCodeKill/choosing-a-javascript-framework-535745d0ab90#.2op7rjakk">
    справедливым</a>. Каждый из фреймворков по-своему будет влиять на конечную производительность
    и будет требовать индивидуальной стратегии оптимизации, поэтому
    Вам нужно отчетливо понимать всю подноготную выбранного фреймворка.
    В процессе построения веб-приложения обратите внимание на <a href="https://developers.google.com/web/fundamentals/performance/prpl-pattern/" target="_blank">шаблон PRPL</a> и архитектуру
    <a href="https://developers.google.com/web/updates/2015/11/app-shell" target="_blank">оболочки приложения</a>.
    
</p>
<p>
    <img src="img/PRPL.png" alt="PRPL " />
    <i>PRPL отвечает за выгрузку критично-важных ресурсов, Рендер изначальных маршрутов, Пре-кэширование остальных маршрутов и “ленивая” загрузка остальных маршрутов по запросу.</i>
</p>
<p>
    <img src="img/shell.png" alt="Оболочка приложения">
    <i><a href="https://developers.google.com/web/updates/2015/11/app-shell" target="_blank">Оболочкой приложения</a> называют
        минимальный HTML, CSS, и JavaScript снабжающий интерфейс пользователя.</i>
</p>