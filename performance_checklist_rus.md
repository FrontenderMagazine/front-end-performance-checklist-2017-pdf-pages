<h1>Чеклист производительности Front-End для 2017 </h1>
<p>
    Кто из Вас уже использует прогрессивную загрузку (progressive booting)
    в своих проектах? А как на счет <strong>tree-shaking</strong> и <strong>code-splitting</strong> в React и
    Angular? Успели ли Вы настроить под себя сжатие Brotli или Zopfli, сшивания
    OCSP (OCSP stapling) и сжатие HPACK (HPACK compression)? Не стоит так же забывать
    о подсказках ресурсов (resource hints), клиентских подсказках (client hints)
    и сдерживании CSS— и это не говоря уже о IPv6, HTTP/2 и сервис воркерах?
</p>
<p>
    Давайте вспомним дни, когда производительность часто откладывалась на второй план. Вспоминали о ней аж в конце проекта, и в большинстве случаев это сводилось к минификации, конкатенации и оптимизации содержимого, и, возможно, парой дополнительных строк в конфигурационном файле сервера. Оглядываясь на те времена, понимаешь, что ситуация значительно поменялась с тех пор.
    Производительность касается не только технической стороны вопроса: она действительно важна, нужно учитывать, как может отразится на производительности то или иное решение в момент создания дизайна. Производительность нужно постоянно замерять, отслеживать, и улучшать, и вечно-растущая сложность веб-технологий все чаще бросает разработчику вызов, делая невозможным отслеживание метрик, так как метрики будут значительно отличаться в зависимости от устройства, браузера, сетевого протокола, типа сети и задержки в ней (CDN-ы, ISP, кэши, прокси, фаерволы, балансировщики нагрузки и сами сервера играют большую роль в конечной производительности).

</p>
<p>
    Если бы Вам пришлось сделать обзор на все возможные технологии
    о которых придется помнить в случае если поставлена задача улучшить
    производительность Вашего сайта — от самого начала процесса и до
    финального релиза вебсайта — на что бы Вы обратили свое внимание?
    Ниже приведен (надеюсь, беспристрастный и объективный)
    <strong>чеклист производительности front-end’а для 2017 </strong>— обзор
    всех тем с которыми вам возможно придется столкнуться для обеспечения
    максимально быстрого отклика и плавности работы Вашего вебсайта.
    (Вы так же можете просто <a href="http://provide.smashingmagazine.com/performance-checklist/performance-checklist-1.0.pdf?_ga=1.67706521.905683373.1482741288"><strong>загрузить чеклист в PDF (ENG) (0.129 MB)</strong></a> ,
    <a href="#"
       target="_blank"><strong>загрузить чеклист в PDF (RUS) (0.129 MB)</strong></a>
    или <a href="http://provide.smashingmagazine.com/performance-checklist/performance-checklist-1.0.pages?_ga=1.63331879.905683373.1482741288"><strong>скачать чеклист в формате Apple Pages (ENG) (0.236 MB)</strong></a>. Cчастливой оптимизации!)

</p>

<h1>
    Чеклист производительности Front-End’а в 2017
</h1>
<p>
    Текущие микро-оптимизации — это отличная вещь, чтобы удерживать Ваш продукт в строю, но гораздо важнее предопределить какие цели перед Вами стоят и не забывать о них — измеримые цели, которые будут влиять на любые решения, принимаемые на протяжении всего процесса. Существует множество разнообразных моделей, и приведенные ниже – могут варьироваться, но главное — расставить в своем проекте правильные приоритеты.
</p>
<h2>ГОТОВИМСЯ, СТАВИМ ЦЕЛИ </h2>
<h3>
    1. Будь на 20% быстрее ближайшего соперника.
</h3>
<p>
    По результатам психологического исследования, оказалось, что если вы хотите
    что пользователь ощущал что Ваш вебсайт быстрее других, нужно быть как-минимум
    на 20% быстрее.  Не столь важно время полной загрузки и отображения страницы,
    как метрики, например, время начала рендера страницы, <a href="https://developers.google.com/web/tools/lighthouse/audits/first-meaningful-paint" target="_blank">первой
    значительной отрисовки страницы </a> (к примеру, время необходимое
    что бы страница отобразила ее преймущественный контент) и <a href="https://developers.google.com/web/tools/lighthouse/audits/time-to-interactive" target="_blank">время интерактивности</a>
    (то есть, время необходимое странице или, в большинстве
    случаев, SPA что бы предоставить пользователю возможность взаимодействия с ней).
    Измерить время начала рендера (с помощью <a href="http://www.webpagetest.org/" target="_blank">WebPagetest</a>)
    и время отображения первой
    значимой картинки (с помощью <a href="https://github.com/GoogleChrome/lighthouse" target="_blank">Lighthouse</a>) на  Moto G, на устройстве Samsung
    среднего уровня производительности и на добротном среднестатистическом устройстве,
    например Nexus 4, желательно (<i>пометка переводчика – для прогрессивного мира</i>)
    в <a href="https://www.smashingmagazine.com/2016/11/worlds-best-open-device-labs/" target="_blank">открытой лаборатории девайсов</a> (open device lab) — на стандартных скоростях 3G,
    4G и при подключении к точке доступа Wi-Fi.

</p>
<p>
    <img src="img/lighthouse.png" alt="Lighthouse, ПО для ревизии производительности от Google" />
    <br>  <i><strong>Lighthouse</strong>, ПО для ревизии производительности от Google.</i>
</p>
<p>
    Обратите внимание на Вашу аналитику, что бы определить, на чем зацикливаются пользователи.
    Тогда Вы сможете сымитировать 90% пользовательского экспириенса синтетическим
    тестированием. Соберите информацию, составьте таблицу, ужмите ее на 20%
    и таким образом определитесь с Вашими целями
    (например, с <a href="http://bradfrost.com/blog/post/performance-budget-builder/" target="_blank">бюджетом производительности</a>).
    Теперь у Вас есть что-то измеримое, на что нужно ориентироваться в тестировании. Держа в голове мысль о бюджете производительности, и предпринимая попытки написания хоть малейшего скрипта для уменьшения времени интерактивности Вы можете быть уверены, что вы на верном пути.
</p>
<p>
    <img src="img/perf_budget.png" alt="Билдер бюджета производительности от Брэда Фроста." />
    <br>
    <i><a href="http://bradfrost.com/blog/post/performance-budget-builder/" target="_blank">Билдер</a> бюджета производительности от Брэда Фроста.</i>

</p>
<p>
  <strong>
      Поделитесь чеклистом с коллегами.
  </strong>
    Удостоверьтесь что каждый член Вашей команды ознакомлен с данным чеклистом что бы избежать возможного недопонимания в будущем процессе. Каждое принятое решение имеет влияние на производительность, и проект будет только в выигрыше, если не только фронтендеры, но и UX и графические дизайнеры решаться следовать этому плану. Обозначьте решения дизайнера в бюджете производительности и расставьте приоритеты о которых упоминалось выше.


</p>
<h3>
    2. Время отклика 100-миллисекунд, 60 кадров в секунду.
</h3>
<p>
    Модель производительности RAIL ставит перед Вами амбициозные цели: приложите все усилия и предоставьте пользователю отклик в течении 100 миллисекунд после первого входа. Для создания возможности отклика <100 миллисекунд страница должна уступать управление главному потоку не позже чем через каждые <50 миллисекунд. Для точек повышенной нагрузки, как анимация, лучшим решением будет не добавлять ничего больше там, где Вы еще можете, и лишь самый минимум там, где вы уже не можете.
    Более того, каждый кадр анимации должен сменятся менее чем за 16 миллисекунд, тем самым Вы достигнете заветных 60 fps (1 секунда ÷ 60 = 16.6 миллисекунд) — а еще лучше – уложиться в пределы 10 миллисекунд. Вашему браузеру ведь нужно время что бы отрисовать новый кадр на экране, так что постарайтесь что бы исполнение Вашего кода завершилось в течении 16.6 миллисекунд.
    <a href="http://info.meteor.com/blog/optimistic-ui-with-meteor-latency-compensation" TARGET="_blank">Будьте оптимистом </a>и используйте время простоя с умом. Очевидно, что эта цель относится в большей степени к производительности во время выполнения, а не во время загрузки.


</p>
<h3>
    3. Первая значимая картинка через 1.25 секунды, индекс скорости меньше 1000.
</h3>
<p>
    Несмотря на сложность достижения, Вашей абсолютной целью должно быть начало отрисовки страницы уже через 1 секунду и значение
    <a href="https://sites.google.com/a/webpagetest.org/docs/using-webpagetest/metrics/speed-index" target="_blank">индекса скорости</a> менее 1000 (на высокоскоростном подключении). Максимально-допустимая длительность отрисовки первого значимого изображения – 1250 миллисекунд. Для мобильных устройств
    <a href="https://www.soasta.com/blog/google-mobile-web-performance-study/" target="_blank"> неплохим</a> показателем будет начало отрисовки страницы меньше чем через 3 секунды для 3G подключения. Если Ваши показатели слегка перевалили за это значения – ничего страшного, но старайтесь понизить эти показатели как можно сильнее.
</p>
<h2>
    ОПРЕДЕЛИМСЯ С ОКРУЖЕНИЕМ
</h2>
<h3>
    4. Выберите для себя и сконфигурируйте инструменты сборки.
</h3>
<p>
    Не стоит слишком зацикливаться на том, что считается трендовым инструментом в данный момент. Придерживайтесь в выборе собственных интересов в разработке, не важно будет ли это Grunt, Gulp, Webpack, PostCSS или комбинация инструментов. До тех пор, пока Вам удается получать достичь результатов быстро, и Вы не ощущаете проблем в процессе использования инструментов сборки – у Вас должно быть все хорошо.
</p>
<h3>
    5. Прогрессивное улучшение.
</h3>
<p>
    Смело делайте ставку на <a href="https://www.aaron-gustafson.com/notebook/insert-clickbait-headline-about-progressive-enhancement-here/" target="_blank">прогрессивное улучшение</a> в качестве ведущего принцип архитектуры вашего front-end’а. Сначала спроектируйте и реализуйте базовые возможности, и только потом, дополняйте их сложными фичами для подходящий браузеров, создавая
    <a href="https://resilientwebdesign.com/" target="_blank">отказоустойчивый интерфейс</a>. В том случае если ваш вебсайт работает быстро на медленном устройстве, со слабым браузером и посредственным интернетом, вы точно можете быть уверены, что он будет отлично работать на устройстве побыстрее, с современным браузером и хорошим интернет соединением.
</p>

<h3>
    6. Angular, React, Ember и компания.
</h3>
<p>
    Присмотритесь к Фреймворку, который
    позволяет отрисовать картинку на стороне сервера.
    Не забудьте замерять время загрузки как в режиме отрисовки на сервере,
    так и на клиенте для мобильных устройств, прежде чем приступать
    к работе с Фреймворком. (так как эти изменения в будущем может быть
    невероятно сложно воплотить). Если Вы уже используете JavaScript фреймворк,
    убедитесь, что Ваш выбор является <a href="https://www.youtube.com/watch?v=6I_GwgoGm1w" target="_blank">оптимальным</a> и
    <a href="https://medium.com/@ZombieCodeKill/choosing-a-javascript-framework-535745d0ab90#.2op7rjakk">
    справедливым</a>. Каждый из фреймворков по-своему будет влиять на конечную производительность
    и будет требовать индивидуальной стратегии оптимизации, поэтому
    Вам нужно отчетливо понимать всю подноготную выбранного фреймворка.
    В процессе построения веб-приложения обратите внимание на <a href="https://developers.google.com/web/fundamentals/performance/prpl-pattern/" target="_blank">шаблон PRPL</a> и архитектуру
    <a href="https://developers.google.com/web/updates/2015/11/app-shell" target="_blank">оболочки приложения</a>.
    
</p>
<p>
    <img src="img/PRPL.png" alt="PRPL " />
    <br>  <i>PRPL отвечает за выгрузку критично-важных ресурсов, Рендер изначальных маршрутов, Пре-кэширование остальных маршрутов и “ленивая” загрузка остальных маршрутов по запросу.</i>
</p>
<p>
    <img src="img/shell.png" alt="Оболочка приложения">
    <br>
    <i><a href="https://developers.google.com/web/updates/2015/11/app-shell" target="_blank">Оболочкой приложения</a> называют
        минимальный HTML, CSS, и JavaScript снабжающий интерфейс пользователя.</i>
</p>
<h3>
    7. AMP от ребят из Google или Instant Articles от Facebook?
</h3>
<p>
    В зависимости от Ваших приоритетов и стратегии организации рабочего процесса Вам предстоит выбирать между <a
        href="https://www.ampproject.org/" target="_blank">Google AMP</a> и <a href="https://instantarticles.fb.com/" target="_blank">Instant Articles</a> от Facebook. Конечно, вы можете добиться отличной производительности и без них, но AMP, к примеру, предлагает фреймворк с превосходной производительностью и бесплатным доступом к СDN, а Instant Articles взвинтят показатели производительности на Facebook. Вы, кстати, можете и сами заняться построением
    <a href="https://www.smashingmagazine.com/2016/12/progressive-web-amps/" target="_blank">прогрессивных веб приложений</a>.
</p>
<h3>
    8. Подойдите мудро к вопросу о выборе вашей CDN
</h3>
<p>
    В зависимости от того насколько статична информация на вашем вебсайте,
    Вы можете попробовать использовать вынести часть контента во
    внешний ресурс (<a href="https://www.smashingmagazine.com/2015/11/static-website-generators-jekyll-middleman-roots-hugo-review/" target="_blank">static site generator</a>),
    выгрузив ее на CDN и запрашивая оттуда статическую версию контента
    при необходимости, таким образом вы спасётесь от запросов к базе данных.
    Вы даже можете выбрать для себя статические <a href="https://www.smashingmagazine.com/2015/11/modern-static-website-generators-next-big-thing/" target="_blank">
    хостинг-платформы </a> базирующиеся на CDN, обогащая страницы вашего вебсайта
    интерактивностью, в качестве прогрессивного улучшения
    (<a href="https://jamstack.org/">JAMStack</a>).
    <br>
    Обратите внимание, что вы можете использовать CDNы для разгрузки (распределения) динамического контента тоже. Так что не обязательно ограничиваться в использовании CDN только для статического контента. Обязательно перепроверьте выполняет ли выбранная CDN сжатие и преобразование контента, умную выгрузку HTTP/2, имеется ли возможность сборки статической и динамической части контента для страницы на стороне CDN’а (ближайший по расположению сервер для пользователя), и другие необходимые задачи.

</p>
<h2>
    ОПТИМИЗАЦИЯ СБОРКИ
</h2>
<h3>
    9. Установите для себя четкие приоритеты.
</h3>
<p>
    Было бы мудро, для начала ознакомиться с чем Вам придется работать. Проведите «инвентаризацию» всех своих ресурсов и контента (JavaScript, изображения, шрифты, внешние скрипты, и “увесистые” модули на странице, такие как карусели, сложная инфографика, и мультимедийный контент), и разделите их на группы.
    <br>
    Составьте таблицу. Определите <strong>основные моменты</strong> для устаревших
    браузеров (т. е. полностью доступный основной контент), затем,
    <strong>улучшенный</strong> интерфейс для подходящих браузеров
    (т.е. улучшенный функционал, полный интерфейс взаимодействия) и
    <strong>дополнения</strong>(активы, который не являются абсолютно-необходимыми
    и могут быть подгружены позже (lazy-load),
    такие как веб шрифты, излишние стили, скрипты каруселей, видеоплейеры,
    кнопки социальных сетей, крупные изображения).
    В качестве примера рекомендуется к рассмотрению статья
    "<a href="https://www.smashingmagazine.com/2014/09/improving-smashing-magazine-performance-case-study/" target="_blank">Improving Smashing Magazine’s Performance</a>" , которая описывает этот подход в подробностях.
</p>
<h3>
    10. Используйте технику «Сбора вершков»
</h3>
<p>
    Что бы развернуть главную часть интерфейса в устаревших браузерах и
    добавить продвинутый функционал для современных браузеров - используйте
    технику <a href="http://responsivenews.co.uk/post/18948466399/cutting-the-mustard" target="_blank">«Сбора вершков»</a>. Распределите
    процесс на стадии четко: Выгрузите главную часть моментально,
    улучшения – по событию <code>DomContentLoaded</code> и прочие дополнения по событию <code>load</code>.
    Обратите внимание что данная техника уменьшает зависимость
    производительности браузера от устройства, и это что в наше
    время все еще имеет смысл. Например, в развивающихся странах,
    дешевые смартфоны на Android в большинстве своем используют
    Chrome и смогут «собрать вершки» несмотря на их ограниченные память
    и возможности процессора. Знайте, что, поскольку у нас с
    Вами нет альтернативы данной техники использование этой техники
    в последнее время стало более ограниченным.

</p>
<h3>
    11. Обратите внимание на микро-оптимизацию и прогрессивную загрузку.
</h3>
<p>
    В некоторых приложениях может понадобится какое-то время прежде чем
    вы сможет отрендерить страницу. Гораздо лучшим решением будет
    показывать
    <a href="https://twitter.com/lukew/status/665288063195594752" target="_blank">скелет приложения</a>
    вместо индикаторов     загрузки. Присмотритесь поближе к модулям
    и техникам по уменьшению
    скорости изначальной отрисовки страницы (Например, <a href="https://medium.com/@richavyas/aha-moments-from-ngconf-2016-part-1-angular-2-0-compile-cycle-6f462f68632e#.8b9afnsub" target="_blank">tree-shaking</a> и
    <a href="https://webpack.github.io/docs/code-splitting.html" target="_blank">разделение кода</a>), потому что большинство времени тратится именно
    на этом этапе на парсинг информации для приложения.
    Также используйте <a href="https://www.lucidchart.com/techblog/2016/09/26/improving-angular-2-load-times/">преждевременный компилятор</a>
    чтобы <a href="https://www.smashingmagazine.com/2016/03/server-side-rendering-react-node-express/" target="_blank">выполнить как можно весомую </a>часть рендера на
    <a href="http://redux.js.org/docs/recipes/ServerRendering.html">сервере</a>
     и     следовательно выведите используемые данные быстро.
    В конце концов возьмите на вооружение <a href="https://github.com/nolanlawson/optimize-js" target="_blank">Optimize.js </a>для
    ускоренной по средствам обертывания часто-используемых функций
    загрузки (<a href="https://twitter.com/tverwaes/status/809788255243739136" target="_blank">это может быть и не нужно</a>).
</p>
<p>
    <img src="img/progressive_booting.png" alt="Progressive booting"><br>
    <i><a href="https://aerotwist.com/blog/when-everything-is-important-nothing-is/" target="_blank">
        Прогрессивная загрузка
    </a>
        подразумевает использование отрисовки страницы на сервере что бы получить первую значимую картинку максимально быстро, а также подключите минимальный JavaScript, чтобы привести время интерактивности ближе к времени отрисовки первой значимой картинки.
    </i>

</p>
<p>
    Рендер на клиенте или на сервере? В обоих случая нашей целью должно
    быть добиться <a href="https://aerotwist.com/blog/when-everything-is-important-nothing-is/" target="_blank">прогрессивной загрузки</a>:
    Используйте рендер на стороне сервера что бы получить первую значимую
    картинку как можно быстрее, а так же добавьте немного JavaScript’а что бы
    привести время интерактивности к времени первой значимой картинки.
    А догрузить (или по запросу или когда позволит время) менее значимые
    функции страницы мы всегда успеем. К сожалению, как заметил
    <a href="https://aerotwist.com/blog/when-everything-is-important-nothing-is/#which-to-use-progressive-booting" target="_blank">Пол Льюис</a>, в
    большинстве своем фреймворки не берут во внимание понятие приоритетности
    которое можно было бы использовать разработчику, и поэтому прогрессивную
    загрузку довольно сложно имплементировать с большинством библиотек и фреймворков.
    Если Вам позволяет время и ресурсы используйте эту стратегию что бы достичь
    идеальной загрузки.


</p>
<h3>
    12. Правильно ли настроены HTTP заголовки?
</h3>



<h2>
    ТЕСТИРОВАНИЕ И МОНИТОРИНГ
</h2>
<h3>
    30. Отслеживайте предупреждения микс-контента (mixed-content).
</h3>
<p>
    Если Вы не так давно перешли с HTTP на HTTPS,
    не забудьте промониторить предупреждения микс-контента,
    как активного так и пассивного, для этого подойдёт инструмент
    <a href="https://report-uri.io/" target="_blank">Report-URI.io</a>.
    Вы также можете использовать <a href="https://github.com/bramus/mixed-content-scan">
    Mixed Content Scan</a>
    что бы просканировать
    Ваш вебсайт с активированным HTTPS-на содержание микс-контента.
</p>
<h3>
    31. Оптимизирован ли Ваш рабочий процесс с Инструментами разработчика (DevTools)?
</h3>
<p>
    Выберите для себя инструменты отладки и прокликайте каждую кнопку,
    ссылку. Убедитесь, что Вы знаете, как проанализировать и улучшать
    производительность отрисовки страницы, консольный вывод, и,
    как отладить JavaScript или корректировать CSS стили.
    Не так давно Умар Ганза (Umar Hansa)
    подготовил огромную <a href="https://umaar.github.io/devtools-optimise-your-web-development-workflow-2016/#/" target="_blank">презентацию</a> и <a href="https://www.youtube.com/watch?v=N33lYfsAsoU" target="_blank">речь</a>,
    в которых упоминаются дюжины неизведанных советов и техник
    о которых не стоит забывать, когда дело доходит до отладки
    и тестирования в Инструментах разработчика (DevTools).
</p>
<h3>
    32. Какие результаты тестирования в устаревших браузерах? В прокси браузерах?
</h3>
<p>
    Тестирования в Chrome и Firefox, однозначно недостаточно.
    Оцените, как Ваш вебсайт выглядит в прокси-браузере и в устаревших браузерах.
    К примеру, UC Browser и Opera Mini, <a href="http://gs.statcounter.com/#mobile_browser-as-monthly-201511-201611" target="_blank">
    занимают огромный сегмент рынка в Азии</a>
    (до 35% в Азии). <a href="https://www.webworldwide.io/" target="_blank">
    Исследуйте и замерьте</a> среднюю скорость подключения к сети в странах,
    на которых ориентирован Ваш продукты, чтобы в будущем не столкнуться с
    неприятным сюрпризом. Не забудьте провести тестирование с троттлингом и симулируйте дисплей повышенной плотности.
    <a href="https://www.browserstack.com/" target="_blank">BrowserStack</a>  - это отличный инструмент, но тестирование на физических девайсах не менее.
</p>

<h3>
    33. Вы установили непрерывный мониторинг?
</h3>
<p>
    Всегда гораздо выгоднее иметь собственный экземпляр <a href="http://www.webpagetest.org/" target="_blank">
    WebPagetest
</a>'а для быстрых и неограниченных тестирований.
    Установите непрерывный мониторинг за бюджетом производительности с
    автоматическими извещениями. Установите собственные временные оценки
    что бы измерять, сравнивать и мониторить метрики в зависимости от сферы
    деятельности. Присмотритесь к использованию <a href="https://speedcurve.com/" target="_blank">
SpeedCurve</a> чтобы отслеживать изменения в производительности со временем, и/или
    <a href="https://newrelic.com/browser-monitoring" target="_blank">
        New Relic</a> что бы получить выводы, которые
    <i>WebPagetest</i> не предоставляет. Стоит так же обратить внимание на
    <a href="https://speedtracker.org/" target="_blank">SpeedTracker</a>,
    <a href="https://github.com/GoogleChrome/lighthouse" target="_blank">Lighthouse</a> и
    <a href="https://calibreapp.com/" target="_blank">Calibre</a>.
</p>

<h2>
    Моментальный результат!
</h2>
<p>
    Список достаточно обширный, и выполнение оптимизация может отнять у Вас
    порядочно времени. А что если бы у Вас был лишь 1 час что бы добиться значительных улучшений? Какое бы решение приняли Вы? Давайте сузим список до десятки самых просто-достижимых целей. Очевидно, Вам придется замерять результаты до начала и после окончания оптимизации, включая время начала рендера и Индекс скорости на 3G и проводном подключении.
</p>
<ol>
    <li>Вашей целью является начало отрисовки страницы не позже чем через 1 секунду на проводном подключении и 3 секунды используя 3G, и индекс скорости величиной менее 1000. Оптимизируйте время начала отрисовки и время интерактивности.</li>
    <li>Подготовьте критичный CSS для основных шаблонов, и включите их в <code>
        &lthead&gt</code> вашей страницы. (Ваш бюджет - 14 KB).</li>
    <li>Используйте <i>Defer</i> и <i>lazy-load</i> во всех скриптах, где только возможно, как в своих собственных, так и в сторонних — особенно это касается социальных медиа ссылок, видеоплейеров, и увесистого JavaScript.</li>
    <li>Добавьте подсказки ресурсов, чтобы ускорить загрузки с быстрым <code>dns-lookup, preconnect, prefetch, preload и prerender</code>.</li>
    <li>Разделите веб шрифты и загружайте их асинхронно (или просто переключайтесь на системные шрифты, как альтернатива).</li>
    <li>Оптимизируйте изображения, рассмотрите возможность использования WebP для основных страниц (например, лэндингов).</li>
    <li>Удостоверьтесь что сами заголовки кэша HTTP и их безопасность установлены правильно.</li>
    <li>Активируйте сжатие <i>Brotli</i> или <i>Zopfli</i> на сервере. (В случае если это невозможно, не забывайте про сжатие Gzip.)</li>
    <li>Если HTTP/2 доступен, активируйте сжатие HPACK и начните отслеживать предупреждения смешанного контента. Если вы работаете над LTS, также активируйте сшивание OCSP.</li>
    <li>Если представляется возможным, кэшируйте содержимое, например, шрифты, стили, скрипты и изображения, а вообще, чем больше – тем лучше! — в кэши сервис воркеров.</li>
</ol>





<h2>
    Скачайте чеклист для себя(PDF)
</h2>
<p>
    Держа в голове этот чеклист, вы гарантированно будете подготовлены к разработке любого front-end проекта в 2017 году. Не забывайте скачать PDF файл с чеклистом, подготовленным для печати для Ваших нужд:
</p>
<ul>
    <li><a href="http://provide.smashingmagazine.com/performance-checklist/performance-checklist-1.0.pdf" target="_blank">
        Download the checklist PDF </a></li>
    <li><a href="#" target="_blank">
        Скачать чеклист в PDF на русском </a></li>
    <li><a href="http://provide.smashingmagazine.com/performance-checklist/performance-checklist-1.0.pages?_ga=1.131076231.905683373.1482741288" target="_blank">
    download the checklist in Apple Pages </a></li>
</ul>
<h1>
    Ну что ж, поехали!
</h1>
<p>
    Некоторая часть процесса оптимизации может выходить за рамки вашего проекта и/или бюджета, а также быть попросту невыполнимым заданием, работая, скажем, с доисторическим кодом, который Вам достался. Это вполне нормально! Рекомендуется использовать данный чеклист как общие (и, надеюсь, фундаментальные) инструкции, или создать на его основе свой собственный список тем, которые будут применимы для Вашего проекта. Кстати, не забывайте протестировать и замерить результаты Ваших проектов до начала оптимизации, чтобы определить наиболее важные моменты. Удачной всем оптимизации в новом, 2017 году!
</p>





