<h1>Чеклист производительности Front-End для 2017 </h1>
<p>
    Кто из Вас уже использует прогрессивную загрузку
    в своих проектах? А как на счет <strong>tree-shaking</strong> и <strong>code-splitting</strong> в React и
    Angular? Успели ли Вы настроить под себя сжатие Brotli или Zopfli, сшивания
    OCSP (OCSP stapling) и сжатие HPACK (HPACK compression)? Не стоит так же забывать
    о подсказках ресурсов (resource hints), клиентских подсказках (client hints)
    и сдерживании CSS— и это не говоря уже о IPv6, HTTP/2 и сервис воркерах?
</p>
<p>
    Давайте вспомним дни, когда производительность часто откладывалась на второй план. Вспоминали о ней аж в конце проекта, и в большинстве случаев это сводилось к минификации, конкатенации и оптимизации содержимого, и, возможно, парой дополнительных строк в конфигурационном файле сервера. Оглядываясь на те времена, понимаешь, что ситуация значительно поменялась с тех пор.
    Производительность касается не только технической стороны вопроса: она действительно важна, нужно учитывать, как может отразится на производительности то или иное решение в момент создания дизайна. Производительность нужно постоянно замерять, отслеживать, и улучшать, и вечно-растущая сложность веб-технологий все чаще бросает разработчику вызов, делая невозможным отслеживание метрик, так как метрики будут значительно отличаться в зависимости от устройства, браузера, сетевого протокола, типа сети и задержки в ней (CDN-ы, ISP, кэши, прокси, фаерволы, балансировщики нагрузки и сами сервера играют большую роль в конечной производительности).

</p>
<p>
    Если бы Вам пришлось сделать обзор на все возможные технологии
    о которых придется помнить в случае если поставлена задача улучшить
    производительность Вашего сайта — от самого начала процесса и до
    финального релиза вебсайта — на что бы Вы обратили свое внимание?
    Ниже приведен (надеюсь, беспристрастный и объективный)
    <strong>чеклист производительности front-end’а для 2017 </strong>— обзор
    всех тем с которыми вам возможно придется столкнуться для обеспечения
    максимально быстрого отклика и плавности работы Вашего вебсайта.
    (Вы так же можете просто <a href="http://provide.smashingmagazine.com/performance-checklist/performance-checklist-1.0.pdf?_ga=1.67706521.905683373.1482741288"><strong>загрузить чеклист в PDF (ENG) (0.129 MB)</strong></a> ,
    <a href="#"
       target="_blank"><strong>загрузить чеклист в PDF (RUS) (0.129 MB)</strong></a>
    или <a href="http://provide.smashingmagazine.com/performance-checklist/performance-checklist-1.0.pages?_ga=1.63331879.905683373.1482741288"><strong>скачать чеклист в формате Apple Pages (ENG) (0.236 MB)</strong></a>. Cчастливой оптимизации!)

</p>

<h1>
    Чеклист производительности Front-End’а в 2017
</h1>
<p>
    Текущие микро-оптимизации — это отличная вещь, чтобы удерживать Ваш продукт в строю, но гораздо важнее предопределить какие цели перед Вами стоят и не забывать о них — измеримые цели, которые будут влиять на любые решения, принимаемые на протяжении всего процесса. Существует множество разнообразных моделей, и приведенные ниже – могут варьироваться, но главное — расставить в своем проекте правильные приоритеты.
</p>
<h2>ГОТОВИМСЯ, СТАВИМ ЦЕЛИ </h2>
<h3>
    1. Будь на 20% быстрее ближайшего соперника.
</h3>
<p>
    По результатам психологического исследования, оказалось, что если вы хотите
    что пользователь ощущал что Ваш вебсайт быстрее других, нужно быть как-минимум
    на 20% быстрее.  Не столь важно время полной загрузки и отображения страницы,
    как метрики, например, время начала рендера страницы, <a href="https://developers.google.com/web/tools/lighthouse/audits/first-meaningful-paint" target="_blank">первой
    значительной отрисовки страницы </a> (к примеру, время необходимое
    что бы страница отобразила ее преймущественный контент) и <a href="https://developers.google.com/web/tools/lighthouse/audits/time-to-interactive" target="_blank">время интерактивности</a>
    (то есть, время необходимое странице или, в большинстве
    случаев, SPA что бы предоставить пользователю возможность взаимодействия с ней).
    Измерить время начала рендера (с помощью <a href="http://www.webpagetest.org/" target="_blank">WebPagetest</a>)
    и время отображения первой
    значимой картинки (с помощью <a href="https://github.com/GoogleChrome/lighthouse" target="_blank">Lighthouse</a>) на  Moto G, на устройстве Samsung
    среднего уровня производительности и на добротном среднестатистическом устройстве,
    например Nexus 4, желательно (<i>пометка переводчика – для прогрессивного мира</i>)
    в <a href="https://www.smashingmagazine.com/2016/11/worlds-best-open-device-labs/" target="_blank">открытой лаборатории девайсов</a> (open device lab) — на стандартных скоростях 3G,
    4G и при подключении к точке доступа Wi-Fi.

</p>
<p>
    <img src="img/lighthouse.png" alt="Lighthouse, ПО для ревизии производительности от Google" />
    <br>  <i><strong>Lighthouse</strong>, ПО для ревизии производительности от Google.</i>
</p>
<p>
    Обратите внимание на Вашу аналитику, что бы определить, на чем зацикливаются пользователи.
    Тогда Вы сможете сымитировать 90% пользовательского экспириенса синтетическим
    тестированием. Соберите информацию, составьте таблицу, ужмите ее на 20%
    и таким образом определитесь с Вашими целями
    (например, с <a href="http://bradfrost.com/blog/post/performance-budget-builder/" target="_blank">бюджетом производительности</a>).
    Теперь у Вас есть что-то измеримое, на что нужно ориентироваться в тестировании. Держа в голове мысль о бюджете производительности, и предпринимая попытки написания хоть малейшего скрипта для уменьшения времени интерактивности Вы можете быть уверены, что вы на верном пути.
</p>
<p>
    <img src="img/perf_budget.png" alt="Билдер бюджета производительности от Брэда Фроста." />
    <br>
    <i><a href="http://bradfrost.com/blog/post/performance-budget-builder/" target="_blank">Билдер</a> бюджета производительности от Брэда Фроста.</i>

</p>
<p>
  <strong>
      Поделитесь чеклистом с коллегами.
  </strong>
    Удостоверьтесь что каждый член Вашей команды ознакомлен с данным чеклистом что бы избежать возможного недопонимания в будущем процессе. Каждое принятое решение имеет влияние на производительность, и проект будет только в выигрыше, если не только фронтендеры, но и UX и графические дизайнеры решаться следовать этому плану. Обозначьте решения дизайнера в бюджете производительности и расставьте приоритеты о которых упоминалось выше.


</p>
<h3>
    2. Время отклика 100-миллисекунд, 60 кадров в секунду.
</h3>
<p>
    Модель производительности RAIL ставит перед Вами амбициозные цели: приложите все усилия и предоставьте пользователю отклик в течении 100 миллисекунд после первого входа. Для создания возможности отклика <100 миллисекунд страница должна уступать управление главному потоку не позже чем через каждые <50 миллисекунд. Для точек повышенной нагрузки, как анимация, лучшим решением будет не добавлять ничего больше там, где Вы еще можете, и лишь самый минимум там, где вы уже не можете.
    Более того, каждый кадр анимации должен сменятся менее чем за 16 миллисекунд, тем самым Вы достигнете заветных 60 fps (1 секунда ÷ 60 = 16.6 миллисекунд) — а еще лучше – уложиться в пределы 10 миллисекунд. Вашему браузеру ведь нужно время что бы отрисовать новый кадр на экране, так что постарайтесь что бы исполнение Вашего кода завершилось в течении 16.6 миллисекунд.
    <a href="http://info.meteor.com/blog/optimistic-ui-with-meteor-latency-compensation" TARGET="_blank">Будьте оптимистом </a>и используйте время простоя с умом. Очевидно, что эта цель относится в большей степени к производительности во время выполнения, а не во время загрузки.


</p>
<h3>
    3. Первая значимая картинка через 1.25 секунды, индекс скорости меньше 1000.
</h3>
<p>
    Несмотря на сложность достижения, Вашей абсолютной целью должно быть начало отрисовки страницы уже через 1 секунду и значение
    <a href="https://sites.google.com/a/webpagetest.org/docs/using-webpagetest/metrics/speed-index" target="_blank">индекса скорости</a> менее 1000 (на высокоскоростном подключении). Максимально-допустимая длительность отрисовки первого значимого изображения – 1250 миллисекунд. Для мобильных устройств
    <a href="https://www.soasta.com/blog/google-mobile-web-performance-study/" target="_blank"> неплохим</a> показателем будет начало отрисовки страницы меньше чем через 3 секунды для 3G подключения. Если Ваши показатели слегка перевалили за это значения – ничего страшного, но старайтесь понизить эти показатели как можно сильнее.
</p>
<h2>
    ОПРЕДЕЛИМСЯ С ОКРУЖЕНИЕМ
</h2>
<h3>
    4. Выберите для себя и сконфигурируйте инструменты сборки.
</h3>
<p>
    Не стоит слишком зацикливаться на том, что считается трендовым инструментом в данный момент. Придерживайтесь в выборе собственных интересов в разработке, не важно будет ли это Grunt, Gulp, Webpack, PostCSS или комбинация инструментов. До тех пор, пока Вам удается получать достичь результатов быстро, и Вы не ощущаете проблем в процессе использования инструментов сборки – у Вас должно быть все хорошо.
</p>
<h3>
    5. Прогрессивное улучшение.
</h3>
<p>
    Смело делайте ставку на <a href="https://www.aaron-gustafson.com/notebook/insert-clickbait-headline-about-progressive-enhancement-here/" target="_blank">прогрессивное улучшение</a> в качестве ведущего принцип архитектуры вашего front-end’а. Сначала спроектируйте и реализуйте базовые возможности, и только потом, дополняйте их сложными фичами для подходящий браузеров, создавая
    <a href="https://resilientwebdesign.com/" target="_blank">отказоустойчивый интерфейс</a>. В том случае если ваш вебсайт работает быстро на медленном устройстве, со слабым браузером и посредственным интернетом, вы точно можете быть уверены, что он будет отлично работать на устройстве побыстрее, с современным браузером и хорошим интернет соединением.
</p>

<h3>
    6. Angular, React, Ember и компания.
</h3>
<p>
    Присмотритесь к Фреймворку, который
    позволяет отрисовать картинку на стороне сервера.
    Не забудьте замерять время загрузки как в режиме отрисовки на сервере,
    так и на клиенте для мобильных устройств, прежде чем приступать
    к работе с Фреймворком. (так как эти изменения в будущем может быть
    невероятно сложно воплотить). Если Вы уже используете JavaScript фреймворк,
    убедитесь, что Ваш выбор является <a href="https://www.youtube.com/watch?v=6I_GwgoGm1w" target="_blank">оптимальным</a> и
    <a href="https://medium.com/@ZombieCodeKill/choosing-a-javascript-framework-535745d0ab90#.2op7rjakk">
    справедливым</a>. Каждый из фреймворков по-своему будет влиять на конечную производительность
    и будет требовать индивидуальной стратегии оптимизации, поэтому
    Вам нужно отчетливо понимать всю подноготную выбранного фреймворка.
    В процессе построения веб-приложения обратите внимание на <a href="https://developers.google.com/web/fundamentals/performance/prpl-pattern/" target="_blank">шаблон PRPL</a> и архитектуру
    <a href="https://developers.google.com/web/updates/2015/11/app-shell" target="_blank">оболочки приложения</a>.
    
</p>
<p>
    <img src="img/PRPL.png" alt="PRPL " />
    <br>  <i>PRPL отвечает за выгрузку критично-важных ресурсов, Рендер изначальных маршрутов, Пре-кэширование остальных маршрутов и “ленивая” загрузка остальных маршрутов по запросу.</i>
</p>
<p>
    <img src="img/shell.png" alt="Оболочка приложения">
    <br>
    <i><a href="https://developers.google.com/web/updates/2015/11/app-shell" target="_blank">Оболочкой приложения</a> называют
        минимальный HTML, CSS, и JavaScript снабжающий интерфейс пользователя.</i>
</p>
<h3>
    7. AMP от ребят из Google или Instant Articles от Facebook?
</h3>
<p>
    В зависимости от Ваших приоритетов и стратегии организации рабочего процесса Вам предстоит выбирать между <a
        href="https://www.ampproject.org/" target="_blank">Google AMP</a> и <a href="https://instantarticles.fb.com/" target="_blank">Instant Articles</a> от Facebook. Конечно, вы можете добиться отличной производительности и без них, но AMP, к примеру, предлагает фреймворк с превосходной производительностью и бесплатным доступом к СDN, а Instant Articles взвинтят показатели производительности на Facebook. Вы, кстати, можете и сами заняться построением
    <a href="https://www.smashingmagazine.com/2016/12/progressive-web-amps/" target="_blank">прогрессивных веб приложений</a>.
</p>
<h3>
    8. Подойдите мудро к вопросу о выборе вашей CDN
</h3>
<p>
    В зависимости от того насколько статична информация на вашем вебсайте,
    Вы можете попробовать использовать вынести часть контента во
    внешний ресурс (<a href="https://www.smashingmagazine.com/2015/11/static-website-generators-jekyll-middleman-roots-hugo-review/" target="_blank">static site generator</a>),
    выгрузив ее на CDN и запрашивая оттуда статическую версию контента
    при необходимости, таким образом вы спасётесь от запросов к базе данных.
    Вы даже можете выбрать для себя статические <a href="https://www.smashingmagazine.com/2015/11/modern-static-website-generators-next-big-thing/" target="_blank">
    хостинг-платформы </a> базирующиеся на CDN, обогащая страницы вашего вебсайта
    интерактивностью, в качестве прогрессивного улучшения
    (<a href="https://jamstack.org/">JAMStack</a>).
    <br>
    Обратите внимание, что вы можете использовать CDNы для разгрузки (распределения) динамического контента тоже. Так что не обязательно ограничиваться в использовании CDN только для статического контента. Обязательно перепроверьте выполняет ли выбранная CDN сжатие и преобразование контента, умную выгрузку HTTP/2, имеется ли возможность сборки статической и динамической части контента для страницы на стороне CDN’а (ближайший по расположению сервер для пользователя), и другие необходимые задачи.

</p>
<h2>
    ОПТИМИЗАЦИЯ СБОРКИ
</h2>
<h3>
    9. Установите для себя четкие приоритеты.
</h3>
<p>
    Было бы мудро, для начала ознакомиться с чем Вам придется работать. Проведите «инвентаризацию» всех своих ресурсов и контента (JavaScript, изображения, шрифты, внешние скрипты, и “увесистые” модули на странице, такие как карусели, сложная инфографика, и мультимедийный контент), и разделите их на группы.
    <br>
    Составьте таблицу. Определите <strong>основные моменты</strong> для устаревших
    браузеров (т. е. полностью доступный основной контент), затем,
    <strong>улучшенный</strong> интерфейс для подходящих браузеров
    (т.е. улучшенный функционал, полный интерфейс взаимодействия) и
    <strong>дополнения</strong>(активы, который не являются абсолютно-необходимыми
    и могут быть подгружены позже (lazy-load),
    такие как веб шрифты, излишние стили, скрипты каруселей, видеоплейеры,
    кнопки социальных сетей, крупные изображения).
    В качестве примера рекомендуется к рассмотрению статья
    "<a href="https://www.smashingmagazine.com/2014/09/improving-smashing-magazine-performance-case-study/" target="_blank">Improving Smashing Magazine’s Performance</a>" , которая описывает этот подход в подробностях.
</p>
<h3>
    10. Используйте технику «Сбора вершков»
</h3>
<p>
    Что бы развернуть главную часть интерфейса в устаревших браузерах и
    добавить продвинутый функционал для современных браузеров - используйте
    технику <a href="http://responsivenews.co.uk/post/18948466399/cutting-the-mustard" target="_blank">«Сбора вершков»</a>. Распределите
    процесс на стадии четко: Выгрузите главную часть моментально,
    улучшения – по событию <code>DomContentLoaded</code> и прочие дополнения по событию <code>load</code>.
    Обратите внимание что данная техника уменьшает зависимость
    производительности браузера от устройства, и это что в наше
    время все еще имеет смысл. Например, в развивающихся странах,
    дешевые смартфоны на Android в большинстве своем используют
    Chrome и смогут «собрать вершки» несмотря на их ограниченные память
    и возможности процессора. Знайте, что, поскольку у нас с
    Вами нет альтернативы данной техники использование этой техники
    в последнее время стало более ограниченным.

</p>
<h3>
    11. Обратите внимание на микро-оптимизацию и прогрессивную загрузку.
</h3>
<p>
    В некоторых приложениях может понадобится какое-то время прежде чем
    вы сможет отрендерить страницу. Гораздо лучшим решением будет
    показывать
    <a href="https://twitter.com/lukew/status/665288063195594752" target="_blank">скелет приложения</a>
    вместо индикаторов     загрузки. Присмотритесь поближе к модулям
    и техникам по уменьшению
    скорости изначальной отрисовки страницы (Например, <a href="https://medium.com/@richavyas/aha-moments-from-ngconf-2016-part-1-angular-2-0-compile-cycle-6f462f68632e#.8b9afnsub" target="_blank">tree-shaking</a> и
    <a href="https://webpack.github.io/docs/code-splitting.html" target="_blank">разделение кода</a>), потому что большинство времени тратится именно
    на этом этапе на парсинг информации для приложения.
    Также используйте <a href="https://www.lucidchart.com/techblog/2016/09/26/improving-angular-2-load-times/">преждевременный компилятор</a>
    чтобы <a href="https://www.smashingmagazine.com/2016/03/server-side-rendering-react-node-express/" target="_blank">выполнить как можно весомую </a>часть рендера на
    <a href="http://redux.js.org/docs/recipes/ServerRendering.html">сервере</a>
     и     следовательно выведите используемые данные быстро.
    В конце концов возьмите на вооружение <a href="https://github.com/nolanlawson/optimize-js" target="_blank">Optimize.js </a>для
    ускоренной по средствам обертывания часто-используемых функций
    загрузки (<a href="https://twitter.com/tverwaes/status/809788255243739136" target="_blank">это может быть и не нужно</a>).
</p>
<p>
    <img src="img/progressive_booting.png" alt="Progressive booting"><br>
    <i><a href="https://aerotwist.com/blog/when-everything-is-important-nothing-is/" target="_blank">
        Прогрессивная загрузка
    </a>
        подразумевает использование отрисовки страницы на сервере что бы получить первую значимую картинку максимально быстро, а также подключите минимальный JavaScript, чтобы привести время интерактивности ближе к времени отрисовки первой значимой картинки.
    </i>

</p>
<p>
    Рендер на клиенте или на сервере? В обоих случая нашей целью должно
    быть добиться <a href="https://aerotwist.com/blog/when-everything-is-important-nothing-is/" target="_blank">прогрессивной загрузки</a>:
    Используйте рендер на стороне сервера что бы получить первую значимую
    картинку как можно быстрее, а так же добавьте немного JavaScript’а что бы
    привести время интерактивности к времени первой значимой картинки.
    А догрузить (или по запросу или когда позволит время) менее значимые
    функции страницы мы всегда успеем. К сожалению, как заметил
    <a href="https://aerotwist.com/blog/when-everything-is-important-nothing-is/#which-to-use-progressive-booting" target="_blank">Пол Льюис</a>, в
    большинстве своем фреймворки не берут во внимание понятие приоритетности
    которое можно было бы использовать разработчику, и поэтому прогрессивную
    загрузку довольно сложно имплементировать с большинством библиотек и фреймворков.
    Если Вам позволяет время и ресурсы используйте эту стратегию что бы достичь
    идеальной загрузки.


</p>
<h3>
    12. Правильно ли настроены HTTP заголовки?
</h3>

<p>
    Обязательно перепроверьте что <code>expires, cache-control, max-age</code> и
    другие заголовки кэша HTTP правильно выставлены. В общем, ресурсы
    должны подлегать кэшированию или на очень короткий срок
    (если они могут изменяться) или навсегда (если они неизменны) —
    вы можете просто изменять их версию в URL при необходимости.
    По возможности, используйте <code>Cache-control: immutable,</code>
    предназначенный для защищенных отпечатком пальца статических
    ресурсов, во избежание ре-валидации (на момент написания –
    Декабрь 2016 - поддерживается только в Firefox (supported only in Firefox)
    по транзакциям <code>https:// </code>). Вы можете использовать
    <a href="https://devcenter.heroku.com/articles/increasing-application-performance-with-http-cache-headers" target="_blank">
    праймер заголовков HTTP кэша Хироку </a>,
    <a href="https://jakearchibald.com/2016/caching-best-practices/" target="_blank">
    «Лучшие практики по кешированию» </a> Джейка Арчибальда
    и
    <a href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=en" target="_blank">
    Праймер кэширования HTTP </a> от Ильи Григорика (HTTP caching primer) в
    качестве руководства.

</p>
<h3>
    13. Ограничьте сторонние библиотеки и загружайте JavaScript асинхронно.
</h3>
<p>
    Когда пользователь запрашивает страницу, браузер извлекает HTML и
    строит DOM, потом собирает CSS и строит CSSOM, и только потом генерирует
    дерево рендера, в соответствии с DOM и CSSOM. Если какой-либо скрипт должен
    отработать, по умолчанию, браузер не начинает рендер страницы пока скрипт не
    закончит работу, что вызывает задержки рендера. Нам, разработчикам, приходится
    настойчиво указывать браузеру что не стоит ждать окончания выполнения скриптов
    для начала рендера страницы. Простейшим способом добиться этого являются HTML
    атрибуты defer и async.
    На практике, хорошо бы нам отдавать <a href="http://calendar.perfplanet.com/2016/prefer-defer-over-async/" target="_blank">предпочтение </a><code>defer</code> перед
    <code>async</code> (как
    <a href="https://github.com/h5bp/lazyweb-requests/issues/42" target="_blank">
    поблажку для пользователей IE9</a> и старше (cost to users of Internet
    Explorer), потому что скорее всего иначе Вы сломаете им все скрипты). Также
    постарайтесь ограничить влияние сторонних скриптов и библиотек, особенно кнопок
    социальных сетей и врезок <code>&ltiframe&gt</code>  (карт, например). Вместо этого вы можете
    использовать <a href="https://www.savjee.be/2015/01/Creating-static-social-share-buttons/" target="_blank">
    статические кнопки социальных сетей </a>
    (например, <a href="https://simplesharingbuttons.com/" target="_blank">SSBG</a>)
    и <a href="https://developers.google.com/maps/documentation/static-maps/intro" target="_blank">
    статические ссылки на интерактивные карты</a>.

</p>

<h3>
    14. Правильно ли оптимизированы изображения?
</h3>
<p>
    Как можно больше используйте <a href="https://www.smashingmagazine.com/2014/05/responsive-images-done-right-guide-picture-srcset/" target="_blank">адаптивные изображения</a> с атрибутами <code>srcset,
    sizes</code>  и элементом <code>&ltpicture&gt</code>. Раз мы уже об этом заговорили, удостоверьтесь что
    вы используете <a href="https://www.smashingmagazine.com/2015/10/webp-images-and-performance/" target="_blank">
    WebP формат </a> для работы с изображениями тэга &lt picture &gt и резервным изображением
    в  JPEG ( <a href="https://dev.opera.com/articles/responsive-images/#different-image-types-use-case" target="_blank">
    смотреть пример кода </a>  Анрэаса Боуэнса) or by using content
    negotiation (используя заголовки Accept).
    Sketch нативно поддерживает WebP, и изображения в формате WebP могут
    быть экспортированы из Photoshop используя <a href="http://telegraphics.com.au/sw/product/WebPFormat#webpformat" target="_blank">плагин WebP для Photoshop</a>.
    Конечно, <a href="https://developers.google.com/speed/webp/docs/using" target="_blank">
    возможны и другие варианты</a>.

</p>
<p>
    <img src="img/responsive.png" alt="responsive images breakpoint generator" /> <br>
    <i>
        <a href="http://www.responsivebreakpoints.com/" target="_blank">Генератор брейкпоинтов для адаптивных изображений </a>автоматизирует создание изображений и разметки.
    </i>
</p>
<p>
    Вы также могли бы использовать <a href="https://www.smashingmagazine.com/2016/01/leaner-responsive-images-client-hints/" target="_blank">
    клиентские подсказки</a>, они как раз сейчас
    <a href="http://caniuse.com/#search=client-hints" target="_blank">заручаются поддержкой браузеров</a>.
    Не успеваете заняться сложной разметкой для адаптивности Ваших изображений?
    Вам в помощь <a href="http://www.responsivebreakpoints.com/" target="_blank">Генератор брейкпоинтов для адаптивных изображений</a>
     а также другие сервисы автоматизированной оптимизации изображений,
    например <a href="http://cloudinary.com/documentation/api_and_access_identifiers" target="_blank">Cloudinary</a>. Также, в большинстве случаев, использование одних
    только <code>srcset</code> и <code>sizes</code> принесет значительную выгоду.  Например, ребята из
    Smashing Magazine, используют <code>-opt</code> для имён изображений — например,
    <code>brotli-compression-opt.png</code>; Как только изображение содержит в себе
    постфикс opt, каждый член команды знает, что его уже не нужно оптимизировать.
</p>

<h3>
    15. Выведите оптимизацию изображений на новый уровень.
</h3>
<p>
    Когда Вы работаете над лэндингом, для которого критичным является молниеносная загрузка
    некоторых изображений убедитесь что Ваши  JPEGи прогрессивны и сжаты с помощью <a href="https://github.com/mozilla/mozjpeg" target="_blank">mozJPEG</a>
    (который улучшает скорость начала рендера изображения с помощью манипуляций с
    уровнями сканирования), <a href="http://css-ig.net/pingo" target="_blank">
    Pingo</a> для PNG, <a href="https://kornel.ski/lossygif" target="_blank">Lossy GIF </a> для GIF и SVGOMG для SVG.
    Размойте ненужные части изображения (применяя к ним размытие по Гауссу) что бы
    уменьшить размер изображения, если даже это не помогает, в конце концов можете
    попробовать лишать изображение цвета, черно-белое изображение весит гораздо меньше.
    Для фоновых изображений вполне приемлемым будет экспорт изображений с качеством от 0 до 10%.
    Все еще не довольны результатом? Ну тогда, Вам придется обратиться к <a href="https://jmperezperez.com/medium-image-progressive-loading-placeholder/" target="_blank">технике
    множественных фоновых изображений</a>.

</p>

<h3>
    16. Как обстоят дела с оптимизацией веб шрифтов?
</h3>
<p>
    Велик шанс, что в веб-шрифтах которые вы используете в
    своем проекте присутствуют символы, которые вы не используете.
    Вы могли бы попросить поставщика шрифтов сузить набор
    символов для ваших нужд или <a href="https://www.fontsquirrel.com/tools/webfont-generator" target="_blank">заняться этим самостоятельно</a>,
    Если Вы используете открытые шрифты (например, включая в алфавит только некоторые символы из латиницы) чтобы уменьшить размеры файла.
    <br>
    <a href="http://caniuse.com/#search=woff2" target="_blank">Поддержка WOFF2 </a> великолепна, а для
    подстраховки Вы можете использоваться WOFF и OTF специально
    для браузеров с отстающей поддержкой. Также выберите для себя
    одну из стратегий Зака Лэзермана – <a href="https://www.zachleat.com/web/comprehensive-webfonts/" target="_blank">“Полное руководство
    по стратегиям загрузки шрифтов,” </a> а также используйте кэш
    сервис воркеров для постоянного кэширования шрифтов. Хотите
    быстрых результатов? У Pixel Ambacht есть <a href="https://pixelambacht.nl/2016/font-awesome-fixed/" target="_blank"> краткое исследование</a>
    вопроса (quick tutorial and case study), как привести Ваши
    шрифты в порядок.
</p>
<p>
    <img src="img/fonts.png" alt="Полное руководство по стратегиям загрузки шрифтов">
    <br>
    <i>
        <a href="https://www.zachleat.com/web/comprehensive-webfonts/"> “Полное руководство по стратегиям загрузки шрифтов,”</a>
        Зака Лэзермана предоставляет дюжену опций для улучшения выгрузки шрифтов/
    </i>
</p>
<p>
    Обязательно используйте <a href="https://github.com/typekit/webfontloader" target="_blank">Web Font Loader </a>если Вам приходится
    использовать внешние сервера для загрузки шрифтов.
    <a href="https://www.filamentgroup.com/lab/font-events.html" target="_blank">FOUT лучше чем FOIT</a>; сразу же начните отрисовку текста,
    и загрузите шрифты асинхронно— можете использовать
    <a href="https://github.com/filamentgroup/loadCSS" target="_blank"> loadCSS </a> для этих целей. Вы так же <a
        href="https://www.smashingmagazine.com/2015/11/using-system-ui-fonts-practical-guide/" target="_blank">обойтись и шрифтами
    установленными локально в ОС</a>.
</p>
<h3>
    17. Молниеносно выгрузите критичные CSS стили.
</h3>
<p>
    Что бы быть уверенным на все 100% что Ваш браузер начнет
    рендер страницы настолько быстро, на сколько это возможно,
    <a href="https://www.smashingmagazine.com/2015/08/understanding-critical-css/" target="_blank">общепринятой практикой   </a>становится собирать
    весь CSS необходимый для начала рендера первой видимой части
    страницы (известный как «критично-важный» CSS) и добавлять его
    инлайново в <code> &lt head&gt </code> вашего документа таким образом уменьшая
    запросы зависимости. Из-за ограничения на передачу пакетов во
    время медленной фазы ~ 14 KB это принято считать Вашим бюджетом
    критично важных CSS.  Если Вы выйдете за рамки бюджета, браузер
    совершать дополнительные обращения чтобы выгрузить больше стилей.
    <a href="https://github.com/filamentgroup/criticalCSS" target="_blank">CriticalCSS </a> и <a href="https://github.com/addyosmani/critical" target="_blank">Critical </a>
    позволяют Вам управится с задачей. Вам
    скорее всего понадобится проделать это с каждым шаблоном над
    которым Вы работаете. Если возможно, постарайтесь использовать
    <a href="https://www.filamentgroup.com/lab/performance-rwd.html" target="_blank">условно-инлайновый подход</a>
    представленный Filament Group.
    С появлением HTTP/2, критично-важный CSS можно хранить в
    отдельном файле CSS и выгружать по запросу с сервера с
    помощью сервер пуша не загрязняя HTML. Загвоздка в том,
    что сервер пуш на данный момент не поддерживается и вызывает
    некоторые проблемы с кэшированием (слайд 114 <a href="http://www.slideshare.net/Fastly/http2-what-no-one-is-telling-you" target="_blank">презентации Хумана
    Бэхешти</a>). Результат может <a href="http://calendar.perfplanet.com/2016/http2-push-the-details/" target="_blank">быть негативным</a>, и привести
    к загрязнению сетевых буферов, и предотвращению доставки
    истинных пакетов. Сервер пуш гораздо более эффективен
    на <a href="https://docs.google.com/document/d/1K0NykTXBbbbTlv60t5MyJvXjqKGsCVNYHyLEXIxYMv0/edit" target="_blank">«теплом» соединении</a>  из-за медленного старта TCP.
    Так что Вам может понадобиться создать механизм <a href="https://css-tricks.com/cache-aware-server-push/" target="_blank"> HTTP/s
    сервер пуша осведомленный о кэше</a>. Помните, что новая
    <a href="http://calendar.perfplanet.com/2016/cache-digests-http2-server-push/" target="_blank">спецификация <code>cache-digest </code> </a>снизит потребность
    в создании таких механизмов вручную.

</p>
<h3>
    18. Используйте tree-shaking и code-splitting для уменьшения нагрузки.
</h3>
<p>
    <a href="https://medium.com/@roman01la/dead-code-elimination-and-tree-shaking-in-javascript-build-systems-fb8512c86edf" target="_blank">Tree-shaking</a>  это способ расчистить ваш процесс
    сборки вовлекая только ту часть кода, которая
    действительно используется на продакшене.
    Вы можете пользоваться <a href="http://www.2ality.com/2015/12/webpack-tree-shaking.html" target="_blank">Webpack 2 что бы свести
    к минимум ненужные экспорты кода</a>, (use Webpack
    2 to eliminate unused exports), и <a href="https://github.com/giakki/uncss" target="_blank">UnCSS </a>
    или <a href="https://github.com/geuis/helium-css" target="_blank">
    Helium</a> что бы предотвратить добавление в билд
    неиспользуемых стилей. Также Вы могли бы
    научиться <a href="http://csswizardry.com/2011/09/writing-efficient-css-selectors/" target="_blank">писать эффективные CSS селекторы</a>
    и избегать <a href="https://benfrain.com/css-performance-revisited-selectors-bloat-expensive-styles/" target="_blank">нагромождения весомых стилей</a>.
    <a href="https://webpack.github.io/docs/code-splitting.html">Code-splitting </a>это еще одна фича Webpack’а,
    которая разбивает основание кода на куски и
    подгружает по запросу. Как только
    Вы определите точки разделения вашего кода,
    Webpack сможет позаботиться о зависимостях,
    и выходных файлах. Он, по сути, позволяет
    тебе держать изначальный трафик минимальным и
    запрашивать код при необходимости самим приложением.
    Примите к сведению что <a href="http://rollupjs.org/" target="_blank">Rollup</a> показывает гораздо
    лучшие результаты чем выдает Browserify.
    Раз уж мы заговорили от этом, вам может быть
    также интересен <a href="https://github.com/nolanlawson/rollupify" target="_blank">Rollupify</a>, который превращает
    модули ECMAScript 2015 в один большой CommonJS
    модуль — потому что маленькие модули могут
    требовать, <a href="https://nolanlawson.com/2016/08/15/the-cost-of-small-modules/" target="_blank">на удивление, больших затрат
    производительности</a>, в зависимости от сборщика
    и модульной системы, которой вы пользуетесь.

</p>
<h3>
    19. Улучшайте производительность рендера.
</h3>
<p>
    Изолируйте увесистые элементы с помощью политики <a href="http://caniuse.com/#search=contain" target="_blank">сдерживания CSS</a>
    — например, что бы ограничить  стили браузера для компоновки и
    окраса элементов, для навигации вне канваса, или для виджетов третьей стороны.
    Удостоверьтесь что нет промедлений при прокрутке страницы и при анимации элементов,
    и что пользователь сможет получать стабильные 60 кадров в секунду. Если это не является
    возможным – как минимум предоставьте диапазон значений FPS в рамках 15-60. Используйте
    свойство CSS <code>will-change </code> что бы сообщить браузеру, какие элементы и свойства в будущем
    изменятся. <br>
    Также, <a href="https://aerotwist.com/blog/my-performance-audit-workflow/#runtime-performance" target="_blank">замерьте время производительности рендера </a>(например, в
    <a href="https://developers.google.com/web/tools/chrome-devtools/rendering-tools/" target="_blank">инструментах разработчика  </a>).
    Перед тем как приступить, пройдите бесплатный <a href="https://www.udacity.com/course/browser-rendering-optimization--ud860" target="_blank">курс на Udacity – отпимизация рендера браузером</a>.

</p>
<h3>
    20. Warm up the connection to speed up delivery.
</h3>
<p>
    Используйте скелетный экраны в интерфейсе и ленивую загрузку
    всех увесистых компонентов, как шрифтов fonts, JavaScript, карусели,
    видео и ifram’ы. Используйте <a href="https://w3c.github.io/resource-hints" target="_blank"> ресурсные подсказки</a>
    в целях сохранения времени на <code>dns-prefetch</code>
    (который выполняет DNS lookup в фоновом режиме), <code>preconnect</code>
    (который просит у браузера разрешение на начало рукопожатий
    (DNS, TCP, TLS – так же в фоне), <code>prefetch</code>(который просит браузер
    запрашивать ресурс), <code>prerender</code> (который указывает браузера как отрендерить
    страницу в фоновом режиме) и <code>preload</code> (который, в том числе подготавливает
    ресурсы, до взаимодействия с ними). Обратите внимание, что на практике, в
    зависимости от поддержки браузера, вы скорее посмотрите в сторону <code>preconnect</code>
    чем <code>dns-prefetch</code>, и вы будете очень осторожны с <code>prefetch</code> и <code>prerender</code> — последний
    следует использовать только если вы крайне уверены как пользователь будет себя
    вести и каким будет его следующий шаг (хороший пример – воронка продаж).
</p>
<h3>
    21. Будьте готовы к HTTP/2.
</h3>
<p>
    Вместе с Google, <a href="https://security.googleblog.com/2016/09/moving-towards-more-secure-web.html" target="_blank">двигающимся в сторону
    более безопасного веба</a> и окончательного восприятия
    HTTP  страниц Chrome’ом как «небезопасные»
    вам придется решиться сделать ставку, или на
    конфигурацию окружения <a href="https://http2.github.io/faq/" target="_blank">HTTP/2  или остаться</a> на
    HTTP/1.1.  HTTP/2 <a href="http://caniuse.com/#search=http2" target="_blank">отлично поддерживается</a>;
    Он никуда не денется и в большинстве случаев лучше
    бы Вам принять его сторону. Безусловно, это
    достаточно трудоемкий процесс, но рано или
    поздно, Вам придется перейти на HTTP/2.
    Когда Вы с этим покончите, вы получите
    <a href="https://www.youtube.com/watch?v=RWLzUnESylc&t=1s&list=PLNYkxOF6rcIBTs2KPy1E6tIYaWoFcG3uj&index=25" target="_blank"> отличный прирост в производительности </a>с
    сервис воркерами и сервер пушами.
</p>
<p>
    <img src="img/http2.png" alt="индикатор безопасности">
</p>
<p>
    В итоге, Google собирается помечать все HTTP
    страницы как небезопасные и поменять индикатор
    безопасности на этих страницах на красный треугольник,
    такой же как сейчас у сломанных HTTPS.
    Отрицательный эффект такая миграция на HTTPS,
    может возыметь в случае если Ваша база пользователей
    HTTP/1.1 очень велика, и большая часть из них
    использует устаревшие браузеры и операционные системы.
    В этом случае Вам придется отправлять разные сборки
    приложения, который должны будут адаптироваться под
    <a href="https://rmurphey.com/blog/2015/11/25/building-for-http2" target="_blank">  разные процессы взаимодействия</a>.
    Помните: Установка как миграции так и новой сборки
    могут быть достаточно сложными и время затратными.
    Для последующих частей статьи, предположим, что
    Вы ли уже переключились на HTTP/2 или уже занимаетесь
    этим вопросом.

</p>
<h3>
    22. Правильно внедряйте HTTP/2.
</h3>
<p>
    и еще раз, <a href="https://www.youtube.com/watch?v=yURLTwZ3ehk" target="_blank">обработка контента через HTTP/2</a> serving assets over HTTP/2 требует
    больших доработок и сильно отличается от того, как вы обрабатывали ваши активы раньше.
    Вам придется найти наилучший баланс между упаковки всех модулей в один и загрузки множества
    мелких модулей параллельно. <br>
    С одной стороны, вам может показаться хорошей идеей избежать сливания всех активов вместе,
    и разделись весь Ваш интерфейс на множество маленьких модулей вместо этого, сжимая и
    в процессе сборки, ссылаясь на них с <a href="https://rmurphey.com/blog/2015/11/25/building-for-http2">подходом «скаута»</a> и загружая
    их в параллель. В отличии от одного файла в случае неудачной загрузки не придется
    выгружать полностью все стили и скрипты заново. <br>
    С другой стороны, <a href="http://engineering.khanacademy.org/posts/js-packaging-http2.htm" target="_blank">упаковка всех файлов в один </a>все еще имеет место быть, потому что
    существуют проблемы с отправкой нескольких многих маленьких JavaScript файлов в браузерах.
    Во-первых, <strong>пострадает сжатие</strong>. Компрессия больших файлов изменится в лучшую сторону
    благодаря повторному использованию словаря, что не касается отдельных небольших файлов.
    Ведется работа над улучшением этого момента, но это еще далеко от реальности. Во-вторых,
    браузеры еще не оптимизированы <strong>
    под такой ход работы
</strong> с файлами. Например, Chrome сочтет
    подобные изменения за <a href="https://www.chromium.org/developers/design-documents/inter-process-communication" target="_blank">меж-процессные коммуникации </a>(inter-process communications)
    между каждым из кластеров, поэтому включая сотни файлов вы рискуете сильно потерять в
    производительности.
    
</p>
<p>
    <img src="img/progressive_booting_Archibald.png" alt="попробуйте подгружать CSS прогрессивно ">
    <br>
    <i>

        Что бы достичь лучших результатов используя HTTP/2, 
        попробуйте <a href="https://jakearchibald.com/2016/link-in-body/" target="_blank">подгружать CSS прогрессивно</a>,
        как было предложено Джеком Арчибальдом из Chrome.
        
    </i>
</p>
<p>
    Но вы все еще можете попробовать <a href="https://jakearchibald.com/2016/link-in-body/" target="_blank">загружать CSS прогрессивно</a>.
    Очевидно, что поступая таким образом вы будете активно ущемлять
    пользователей HTTP/1.1, так что Вам может понадобится генерация и
    обработка разных билдов для разных браузеров в процессе вашего деплоймента,
    и тут все становится немного сложнее.
    Вы можете уйти от использования <a href="https://daniel.haxx.se/blog/2016/08/18/http2-connection-coalescing/" target="_blank"> HTTP/2 обьединяющим соединением</a>, что позволяет Вам использовать
    сегментирование доменов, чем значительно отличается от HTTP/2, но на практике достичь этого сложно.
    Так что же делать? Если Ваш вебсайт работает через HTTP/2, отправка около 10 сегментов является неплохим компромиссом (и это совсем не плохо даже для устаревших браузеров). Просто поэкспериментируйте и вычислите нужный баланс для вашего вебсайта.

</p>
<h3>
    23. Удостоверьтесь в пуленепробиваемой защите вашего сервера.
</h3>
<p>
    Все браузерные реализации HTTP/2 работаю через TLS, так что скорее всего Вам захочется
    избежать оповещений безопасности или неработоспособности каких-то элементов на вашей странице.
    Перепроверьте что <a href="https://securityheaders.io/" target="_blank">заголовки безопасности правильно настроены</a>,
    избавьтесь от <a href="https://www.smashingmagazine.com/2016/01/eliminating-known-security-vulnerabilities-with-snyk/" target="_blank">заранее известных
    уязвимостей</a>, и проверьте <a href="https://www.ssllabs.com/ssltest/" target="_blank">Ваш сертификат</a>.
    Все еще не перешли на HTTPS? Присмотритесь к <a href="https://https.cio.gov/faq/" target="_blank">HTTPS-Only Стандарту</a> в качестве инструкции.
 Также, удостоверьтесь что внешние плагины и отслеживающие скрипты загружены через HTTPS,
    что межсайтовый скриптинг невозможен и что как <a href="https://www.owasp.org/index.php/HTTP_Strict_Transport_Security_Cheat_Sheet" target="_blank">строгие заголовки транспортной безопасности </a>HTTP,
    так и <a href="https://content-security-policy.com/">заголовки политики безопасности подключений </a>заданы верно.
</p>

<h3>
    24. Поддерживают ли Ваш сервер и CDNы HTTP/2?
</h3>
<p>
    Разные сервера и CDNы скорее всего будет поддерживать
    HTTP/2 по-разному. Попробуйте <a href="https://istlsfastyet.com/" target="_blank">Is TLS Fast Yet?</a>
    Что-бы уточнить информацию касательно вашего варианта или в сравнении
    с другими узнать насколько производителен Ваш сервер и поддержку каких фич
    стоит ожидать в скором времени.
</p>
<p>
    <img src="img/isitfastyet.png" alt="Ресурс Is TLS Fast Yet?"> <br>
    <i>Ресурс
        <a href="https://istlsfastyet.com/" target="_blank"> Is TLS Fast Yet?</a>
        Позволяет Вам проанализировать конфигурации серверов и CDN при переходе на HTTP/2.
    </i>
</p>
<h3>
    25. Используется ли сжатие Brotli или Zopfli?
</h3>
<p>
    В прошлом году Google <a href="https://opensource.googleblog.com/2015/09/introducing-brotli-new-compression.html" target="
">представили миру Brotli</a>, новый формат данных без потерь,
    который уже <a href="http://caniuse.com/#search=brotli" target="_blank">широко поддерживается </a>в Chrome, Firefox и Opera. На практике, Brotli
    представляется <a href="https://samsaffron.com/archive/2016/06/15/the-current-state-of-brotli-compression" target="_blank">более эффективным</a> чем Gzip и Deflate. Сам процесс
    сжатия может быть затяжным, в зависимости от настроек и чем дольше длится сжатие,
    тем выше будет уровень самого сжатия. Кстати говоря, декомпрессия происходит быстро.
    Не будет сюрпризом что браузеры будут поддерживать этот алгоритм только если пользователь
    посещает вебсайт через HTTPS, ведь алгоритм разработан в Google, но на самом деле, на то
    есть еще и технические причины. Загвоздка в том, что Brotli не предустановлен на большинстве
    серверов сегодня, и не так уж просто его настроить без самостоятельной компиляции NGINX или
    Ubuntu. Однако, вы можете <a href="http://calendar.perfplanet.com/2016/enabling-brotli-even-on-cdns-that-dont-support-it-yet/" target="_blank">активировать Brotli </a> даже на тех CDN, которые пока что его не
    поддерживают (enable Brotli even on CDNs that don’t support it) yet (с помощью сервис воркеров).
    В качестве альтернативы, можете рассмотреть <a href="https://blog.codinghorror.com/zopfli-optimization-literally-free-bandwidth/" target="_blank"> алгоритм сжатия Zopfli</a>
    (Zopfli’s compression algorithm), который кодирует информацию в форматы Deflate,
    Gzip и Zlib. Любой ресурс сжатый простым Gzip-ом можно выгодно сжимать с Zopfli’s
    с улучшеным кодированием Deflate, потому что файлы будут на 3-8% меньше чем может
    предоставить лушчее сжатие от Zlib’s. Загвоздка в тому, что это займет гораздо больше
    времени (~в 80 раз дольше). Поэтому использование Zopfli будет отличным решением для
    ресурсов, которые не очень-то меняются, файлы, которые, были созданы, чтобы однажды
    быть сжатыми и множество раз скачанными.

</p>
<h3>
    26. Активировано ли OCSP сшивание?
</h3>
<p>
    <a href="https://www.digicert.com/enabling-ocsp-stapling.htm" target="_blank">Включая сшивание OCSP </a>на своем сервере,
    Вы сможете значительно ускорить «рукопожатия» протокола
    TLS. Протокол OCSP (Online Certificate Status Protocol)
    был создан в качестве альтернативы для протокола CRL
    (Certificate Revocation List). Оба протокола используются
    для проверки валидности SSL сертификата. Однако, протокол
    OCSP не требует чтобы браузер тратил время, загружая
    список сертификатов и детальную информацию про них для
    поиска, таким образом уменьшая время затраченное на
    «рукопожатие».
</p>
<h3>
    27. Успели ли Вы взять IPv6 на вооружение?
</h3>
<p>
    Поскольку запасы адресов IPv4 <a href="https://en.wikipedia.org/wiki/IPv4_address_exhaustion" target="_blank">подходят к концу</a>,
    большинство мобильных сетей получают поддержку
    IPv6 просто молниеносно
    (США достигли порога в 50% поддержки IPv6),
    будет замечательной идеей обновить поддержку Вашего
    DNS на IPv6  что бы
    в будущем обеспечить себе спокойный сон.
    Просто убедитесь что во всей сети предоставляется
    двойной стэк – IPv4 и IPv6 — это позволит IPv6 и IPv4
    работать одновременно бок о бок. В конце концов, IPv6
    не обратно-совместимый. Также, исследования показали
    что IPv6 сделала эти сайты на 10-15%
    быстрее благодаря техника обнаружения соседа (NDP) и
    оптимизации маршрута.
</p>
<h3>
    28. Пользуетесь ли Вы HPACK сжатием?
</h3>
<p>
    В случае если вы используете HTTP/2, стоит убедиться,
    что Ваши сервера <a href="https://blog.cloudflare.com/hpack-the-silent-killer-feature-of-http-2/" target="_blank">используют сжатие HPACK </a>в заголовках HTTP
    ответов, чтобы уменьшить использование ресурсов.
    Из-за того, что сервера HTTP/2 относительно молоды,
    может иметь место неполноценная поддержка спецификаций,
    с HPACK, например. <a href="https://github.com/summerwind/h2spec" target="_blank">H2spec </a>это отличный
    (и очень детализированный) инструмент что бы проверить
    <a href="https://www.keycdn.com/blog/http2-hpack-compression/" target="_blank">работоспособность HPACK</a>.
</p>
<p>
    <img src="img/HPack%20spec.png" alt="H2speck">
    <br>
    <i>
        H2spec
    </i>
</p>
<h3>
    29. Работают ли сервис воркеры для кэширования и сетевых фолбэков?
</h3>
<p>
    Как ни оптимизируй сетевую передачу данных, она не будет
    быстрее чем получение данных из локального кэша, хранящегося
    на устройстве пользователя. Если Ваш вебсайт использует HTTPS,
    стоит присмотреться к <a href="https://github.com/lyzadanger/pragmatist-service-worker" target="_blank">«Прагматичному гиду по сервис воркерам»</a>
     что бы добавлять в кэш сервис воркеров статические
    материалы и локально хранить офлайн фолбэки
    (или целые офлайн страницы) и открывать их из памяти
    устройства пользователя а не отправляться за ними в.
    Будет полезным также посмотреть <a href="https://jakearchibald.com/2014/offline-cookbook/" target="_blank">«Книгу рецептов для Офлайна»</a>
    от Джейка и бесплатный Udacity курс
    <a href="https://www.udacity.com/course/offline-web-applications--ud899" target="_blank">“Offline Web Applications.”</a> Волнуетесь о поддержке браузерами?
    Не стоит, <a href="http://caniuse.com/#search=serviceworker" target="_blank">она на подходе</a>, да и сеть в любом
    случае останется запасным вариантом.
</p>


<h2>
    ТЕСТИРОВАНИЕ И МОНИТОРИНГ
</h2>
<h3>
    30. Отслеживайте предупреждения микс-контента (mixed-content).
</h3>
<p>
    Если Вы не так давно перешли с HTTP на HTTPS,
    не забудьте промониторить предупреждения микс-контента,
    как активного так и пассивного, для этого подойдёт инструмент
    <a href="https://report-uri.io/" target="_blank">Report-URI.io</a>.
    Вы также можете использовать <a href="https://github.com/bramus/mixed-content-scan">
    Mixed Content Scan</a>
    что бы просканировать
    Ваш вебсайт с активированным HTTPS-на содержание микс-контента.
</p>
<h3>
    31. Оптимизирован ли Ваш рабочий процесс с Инструментами разработчика (DevTools)?
</h3>
<p>
    Выберите для себя инструменты отладки и прокликайте каждую кнопку,
    ссылку. Убедитесь, что Вы знаете, как проанализировать и улучшать
    производительность отрисовки страницы, консольный вывод, и,
    как отладить JavaScript или корректировать CSS стили.
    Не так давно Умар Ганза (Umar Hansa)
    подготовил огромную <a href="https://umaar.github.io/devtools-optimise-your-web-development-workflow-2016/#/" target="_blank">презентацию</a> и <a href="https://www.youtube.com/watch?v=N33lYfsAsoU" target="_blank">речь</a>,
    в которых упоминаются дюжины неизведанных советов и техник
    о которых не стоит забывать, когда дело доходит до отладки
    и тестирования в Инструментах разработчика (DevTools).
</p>
<h3>
    32. Какие результаты тестирования в устаревших браузерах? В прокси браузерах?
</h3>
<p>
    Тестирования в Chrome и Firefox, однозначно недостаточно.
    Оцените, как Ваш вебсайт выглядит в прокси-браузере и в устаревших браузерах.
    К примеру, UC Browser и Opera Mini, <a href="http://gs.statcounter.com/#mobile_browser-as-monthly-201511-201611" target="_blank">
    занимают огромный сегмент рынка в Азии</a>
    (до 35% в Азии). <a href="https://www.webworldwide.io/" target="_blank">
    Исследуйте и замерьте</a> среднюю скорость подключения к сети в странах,
    на которых ориентирован Ваш продукты, чтобы в будущем не столкнуться с
    неприятным сюрпризом. Не забудьте провести тестирование с троттлингом и симулируйте дисплей повышенной плотности.
    <a href="https://www.browserstack.com/" target="_blank">BrowserStack</a>  - это отличный инструмент, но тестирование на физических девайсах не менее.
</p>

<h3>
    33. Вы установили непрерывный мониторинг?
</h3>
<p>
    Всегда гораздо выгоднее иметь собственный экземпляр <a href="http://www.webpagetest.org/" target="_blank">
    WebPagetest
</a>'а для быстрых и неограниченных тестирований.
    Установите непрерывный мониторинг за бюджетом производительности с
    автоматическими извещениями. Установите собственные временные оценки
    что бы измерять, сравнивать и мониторить метрики в зависимости от сферы
    деятельности. Присмотритесь к использованию <a href="https://speedcurve.com/" target="_blank">
SpeedCurve</a> чтобы отслеживать изменения в производительности со временем, и/или
    <a href="https://newrelic.com/browser-monitoring" target="_blank">
        New Relic</a> что бы получить выводы, которые
    <i>WebPagetest</i> не предоставляет. Стоит так же обратить внимание на
    <a href="https://speedtracker.org/" target="_blank">SpeedTracker</a>,
    <a href="https://github.com/GoogleChrome/lighthouse" target="_blank">Lighthouse</a> и
    <a href="https://calibreapp.com/" target="_blank">Calibre</a>.
</p>

<h2>
    Моментальный результат!
</h2>
<p>
    Список достаточно обширный, и выполнение оптимизация может отнять у Вас
    порядочно времени. А что если бы у Вас был лишь 1 час что бы добиться значительных улучшений? Какое бы решение приняли Вы? Давайте сузим список до десятки самых просто-достижимых целей. Очевидно, Вам придется замерять результаты до начала и после окончания оптимизации, включая время начала рендера и Индекс скорости на 3G и проводном подключении.
</p>
<ol>
    <li>Вашей целью является начало отрисовки страницы не позже чем через 1 секунду на проводном подключении и 3 секунды используя 3G, и индекс скорости величиной менее 1000. Оптимизируйте время начала отрисовки и время интерактивности.</li>
    <li>Подготовьте критичный CSS для основных шаблонов, и включите их в <code>
        &lthead&gt</code> вашей страницы. (Ваш бюджет - 14 KB).</li>
    <li>Используйте <i>Defer</i> и <i>lazy-load</i> во всех скриптах, где только возможно, как в своих собственных, так и в сторонних — особенно это касается социальных медиа ссылок, видеоплейеров, и увесистого JavaScript.</li>
    <li>Добавьте подсказки ресурсов, чтобы ускорить загрузки с быстрым <code>dns-lookup, preconnect, prefetch, preload и prerender</code>.</li>
    <li>Разделите веб шрифты и загружайте их асинхронно (или просто переключайтесь на системные шрифты, как альтернатива).</li>
    <li>Оптимизируйте изображения, рассмотрите возможность использования WebP для основных страниц (например, лэндингов).</li>
    <li>Удостоверьтесь что сами заголовки кэша HTTP и их безопасность установлены правильно.</li>
    <li>Активируйте сжатие <i>Brotli</i> или <i>Zopfli</i> на сервере. (В случае если это невозможно, не забывайте про сжатие Gzip.)</li>
    <li>Если HTTP/2 доступен, активируйте сжатие HPACK и начните отслеживать предупреждения смешанного контента. Если вы работаете над LTS, также активируйте сшивание OCSP.</li>
    <li>Если представляется возможным, кэшируйте содержимое, например, шрифты, стили, скрипты и изображения, а вообще, чем больше – тем лучше! — в кэши сервис воркеров.</li>
</ol>





<h2>
    Скачайте чеклист для себя(PDF)
</h2>
<p>
    Держа в голове этот чеклист, вы гарантированно будете подготовлены к разработке любого front-end проекта в 2017 году. Не забывайте скачать PDF файл с чеклистом, подготовленным для печати для Ваших нужд:
</p>
<ul>
    <li><a href="http://provide.smashingmagazine.com/performance-checklist/performance-checklist-1.0.pdf" target="_blank">
        Download the checklist PDF </a></li>
    <li><a href="#" target="_blank">
        Скачать чеклист в PDF на русском </a></li>
    <li><a href="http://provide.smashingmagazine.com/performance-checklist/performance-checklist-1.0.pages?_ga=1.131076231.905683373.1482741288" target="_blank">
    download the checklist in Apple Pages </a></li>
</ul>
<h1>
    Ну что ж, поехали!
</h1>
<p>
    Некоторая часть процесса оптимизации может выходить за рамки вашего проекта и/или бюджета, а также быть попросту невыполнимым заданием, работая, скажем, с доисторическим кодом, который Вам достался. Это вполне нормально! Рекомендуется использовать данный чеклист как общие (и, надеюсь, фундаментальные) инструкции, или создать на его основе свой собственный список тем, которые будут применимы для Вашего проекта. Кстати, не забывайте протестировать и замерить результаты Ваших проектов до начала оптимизации, чтобы определить наиболее важные моменты. Удачной всем оптимизации в новом, 2017 году!
</p>





